(window.webpackJsonp=window.webpackJsonp||[]).push([[281],{623:function(t,a,e){"use strict";e.r(a);var n=e(27),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"多重继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多重继承"}},[t._v("#")]),t._v(" 多重继承")]),t._v(" "),e("p",[t._v("类和接口之间的一个显着的区别是类可以有字段而接口不能。另外，你可以实例化一个类来创建一个对象，这是你不能用接口实现的。正如 "),e("RouterLink",{attrs:{to:"/java/concepts/obgect.html"}},[t._v("什么是对象")]),t._v(" 部分所解释的那样，对象将其状态存储在类中定义的字段中。Java 编程语言不允许你继承多个类的一个原因是为了避免 "),e("strong",[t._v("多重继承状态")]),t._v(" 的问题，这是从多个类继承字段的能力。例如，假设您可以定义一个扩展多个类的新类。当你通过实例化这个类来创建一个对象的时候，这个对象将继承这个类的所有超类的字段。如果来自不同超类的方法或构造函数实例化相同的字段呢？哪个方法或构造函数优先？因为接口不包含字段，所以不必担心由多重状态继承导致的问题。")],1),t._v(" "),e("p",[e("strong",[t._v("实现的多重继承")]),t._v(" 是从多个类继承方法定义的能力。这种类型的多重继承会出现问题，如名称冲突和模糊性。当支持这种类型的多继承的编程语言的编译器遇到包含具有相同名称的方法的超类时，它们有时不能确定访问或调用哪个成员或方法。另外，程序员可以在不知情的情况下通过向超类添加新方法来引入名称冲突。 默认的方法介绍一种多重继承的实现形式。一个类可以实现多个接口，它可以包含具有相同名称的默认方法。Java 编译器提供了一些规则来确定特定类所使用的默认方法。")]),t._v(" "),e("p",[t._v("Java 编程语言支持类型的多重继承，这是一个类实现多个接口的能力。一个对象可以有多种类型：它自己的类的类型和类所实现的所有接口的类型。这意味着如果一个变量被声明为接口的类型，那么它的值可以引用任何实现了接口的类实例化的对象。这在 "),e("RouterLink",{attrs:{to:"/java/iandi/interface_as_type.html"}},[t._v("使用接口作为类型")]),t._v(" 一节中讨论 。")],1),t._v(" "),e("p",[t._v("与实现的多重继承一样，一个类可以继承它所扩展的接口中定义的方法（默认或静态）的不同实现。在这种情况下，编译器或用户必须决定使用哪一个。")])])}),[],!1,null,null,null);a.default=r.exports}}]);