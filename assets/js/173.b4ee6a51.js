(window.webpackJsonp=window.webpackJsonp||[]).push([[173],{663:function(t,s,a){"use strict";a.r(s);var e=a(27),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"缓冲流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓冲流"}},[t._v("#")]),t._v(" 缓冲流")]),t._v(" "),a("p",[t._v("迄今为止我们看到的大多数示例都使用无缓冲的 I / O。这意味着每个读或写请求都由底层操作系统直接处理。\n这可以使程序效率低得多，因为每个这样的请求经常触发磁盘访问，网络活动或相对昂贵的一些其他操作。")]),t._v(" "),a("p",[t._v("为了减少这种开销，Java 平台实现了缓冲的 I / O 流。缓冲输入流从称为缓冲区的存储区读取数据；\n仅当缓冲区为空时才调用本地输入 API。类似地，缓冲输出流将数据写入缓冲区，只有当缓冲区已满时才调用本地输出 API。")]),t._v(" "),a("p",[t._v("程序可以使用我们已经使用过多次的包装习惯将无缓冲流转换为缓冲流，其中将无缓冲流对象传递给缓冲流类的构造函数。以下是在 CopyCharacters 示例中修改构造函数调用以使用缓冲 I / O的方法：")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("inputStream "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BufferedReader")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileReader")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"xanadu.txt"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\noutputStream "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BufferedWriter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileWriter")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"characteroutput.txt"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("p",[t._v("还有用于包装缓冲流 4 个缓冲流类：")]),t._v(" "),a("ul",[a("li",[t._v("BufferedInputStream 与")]),t._v(" "),a("li",[t._v("BufferedOutputStream 创建缓冲字节流，")]),t._v(" "),a("li",[t._v("BufferedReader 与")]),t._v(" "),a("li",[t._v("BufferedWriter 创建缓冲字符流。")])]),t._v(" "),a("h2",{attrs:{id:"冲洗缓冲流（flushing-buffered-streams）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冲洗缓冲流（flushing-buffered-streams）"}},[t._v("#")]),t._v(" 冲洗缓冲流（Flushing Buffered Streams）")]),t._v(" "),a("p",[t._v("在关键点写出缓冲区通常是有意义的，而不用等待填充。这被称为 "),a("strong",[t._v("冲洗缓冲区")]),t._v("。")]),t._v(" "),a("p",[t._v("一些缓冲输出类支持自动刷新，由可选的构造函数参数指定。当 "),a("code",[t._v("autoflush")]),t._v(" 开启时，\n某些关键事件会导致缓冲区被刷新。PrintWriter 对象在每次调用 println 或者 format 时，将自动冲洗缓冲区。\n更多信息请查阅 "),a("RouterLink",{attrs:{to:"/essential/io/scanfor.html"}},[t._v("扫描和格式化")]),t._v(" 章节")],1),t._v(" "),a("p",[t._v("要手动刷新流，请调用其 flush 方法。flush 方法对任何输出流都有效，但除非流被缓冲，否则该方法无效。")])])}),[],!1,null,null,null);s.default=r.exports}}]);