(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{464:function(a,t,e){"use strict";e.r(t);var v=e(27),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"map-实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map-实现"}},[a._v("#")]),a._v(" Map 实现")]),a._v(" "),e("p",[a._v("分为 通用 和 专用实现")]),a._v(" "),e("h2",{attrs:{id:"通用实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通用实现"}},[a._v("#")]),a._v(" 通用实现")]),a._v(" "),e("ul",[e("li",[a._v("HashMap")]),a._v(" "),e("li",[a._v("TreeMap")]),a._v(" "),e("li",[a._v("LinkedHashMap")])]),a._v(" "),e("p",[a._v("如果需要排序可以使用：")]),a._v(" "),e("ul",[e("li",[a._v("SortedMap")]),a._v(" "),e("li",[a._v("TreeMap")])]),a._v(" "),e("p",[a._v("如果想要快速且不关心迭代顺序，使用 HashMap")]),a._v(" "),e("p",[a._v("如果想要性能接近 HashMap 和插入顺序，使用 LinkedHashMap。")]),a._v(" "),e("p",[a._v("对于这种情况，set 与 map 类似。")]),a._v(" "),e("p",[a._v("LinkedHashMap 的 removeEldestEntry 功能，可以用来实现自定义缓存。")]),a._v(" "),e("p",[a._v("如果设置 100个 容量的缓存，put 的时候如果超过了该容量，会把最先进来的元素移除，再把新的加到末尾。该操作在 put 的时候被调用。")]),a._v(" "),e("p",[a._v("大概意思就是这样的。")]),a._v(" "),e("h2",{attrs:{id:"专用实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#专用实现"}},[a._v("#")]),a._v(" 专用实现")]),a._v(" "),e("ul",[e("li",[a._v("EnumMap")]),a._v(" "),e("li",[a._v("WeakHashMap")]),a._v(" "),e("li",[a._v("IdentityHashMap。")])]),a._v(" "),e("p",[a._v("WeakHashMap 中的每个键对象间接地存储为一个弱引用的指示对象。因此，不管是在映射内还是在映射之外，只有在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。")]),a._v(" "),e("h2",{attrs:{id:"并发实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发实现"}},[a._v("#")]),a._v(" 并发实现")]),a._v(" "),e("p",[a._v("java.util.concurrent 包中包含的 ConcurrentMap 接口，它延伸 Map 与原子 putIfAbsent，remove 和 replace 方法，以及 ConcurrentHashMap 该接口的实现。")]),a._v(" "),e("p",[a._v("ConcurrentMap 是哈希表备份的高性能高并发实现。提供其他原子 putIfAbsent、remove、replace 方法的 Map。 替代 Hashtable")])])}),[],!1,null,null,null);t.default=_.exports}}]);